# 2. 値・型・変数

## 2-1. ユーザー情報を扱う

### 概要

プリミティブ型、オブジェクト型、型推論の基礎を学ぶ課題です。  
> **Note:** TypeScriptでは、文字列（string）、数値（number）、真偽値（boolean）などのJavaScriptの基本データ型を「プリミティブ型」と呼びます。これらの型と、オブジェクト型を組み合わせることで、複雑なデータ構造も型安全に扱えるようになります。また、TypeScriptは変数やオブジェクトリテラルから自動的に型を「推論」する機能を備えています。

### 目的・ゴール

- 文字列・数値などの基本型に型アノテーションを付けられるようになる  
- オブジェクト型を定義し、プロパティを正しく扱えるようになる  
- TypeScriptの型推論がどのように働くか理解する  
- 暗黙的な `any` 型の挙動や危険性を知る  

### 手順

1. **`userInfo.ts` ファイルを開いてください。**  
   このファイルには、オブジェクト型と型定義の基礎に関する課題が用意されています。

2. **ファイル内の指示に従って、以下の実装を行ってください：**
   - ユーザーを表す `User` 型の定義  
   - `User` 型を使ったユーザーオブジェクトの作成  
   - ユーザー情報を出力する関数の実装  

3. **型推論を体験してみましょう（追加ステップ）**
   1. 次のように、型注釈なしでユーザーオブジェクトを作成してみてください。

      ```ts
      let userB = {
        name: "Bob",
        age: 30,
        isPremium: false
      };
      ```

   2. `userB` のプロパティにカーソルを合わせ、TypeScript がどのように型を推論しているか確認してください。  
   3. `userB.age = "30歳";` のように**文字列**を代入してみて、エラーになるか確認してください。  
   4. 次に、`let userC: any = { ... };` と書き直し、同様に `"30歳"` を代入してみるとどうなるでしょうか？  
      - どのようにエラーが変化（もしくはエラーが消える）するか、挙動を比較してみてください。  

4. **コードをトランスパイルして実行し、出力結果を確認してください。**

   ```bash
   # プロジェクトのトランスパイル
   npm run build

   # 実行
   node dist/2-values-types-variables/userInfo.js
   ```

5. **実装したコードを部分的に修正して型エラーを発生させ、TypeScriptの型チェックがどのように機能するか確認してください。例：**
   - `User` 型で定義されていないプロパティを使用  
   - プロパティに型に合わない値を代入（文字列型に数値を代入するなど）  
   - 変数宣言時に型注釈をつけずに後から別の型の値を代入してみる  

6. **実装が完了したら、テストを実行して正しく実装できているか確認しましょう。**

   ```bash
   npm run test -- src/2-values-types-variables/userInfo.test.ts
   ```

### チェックポイント

- **オブジェクト型**の定義と使用方法を理解しているか  
- **型注釈なし**（暗黙的な型推論）でも正しい型が推論されることを確認できたか  
- **`any` をつけた場合**に型チェックが効かなくなることを理解しているか  
- プロパティの型を正しく定義できるか  
- 型エラーの原因を正しく把握できるか  
- プロパティの追加・削除や型の変更に対し、TypeScriptが正しくエラーを検出するか  

### 発展課題（任意）

1. **`User` 型に「役職（role）」などオプショナルなプロパティ（`role?: string`）を追加してみましょう。**  
2. **TypeScriptの型ガード**（`typeof` や `instanceof` など）を使った簡単な例を試してみましょう（任意の関数の中で、引数の型が文字列か数値かを判別して処理を分けるなど）。  
3. **インデックスシグネチャ**を使い、動的なプロパティ名を持つオブジェクト型を定義してみましょう。  

   ```ts
   type FlexibleObject = {
     [key: string]: string | number;
   };
   ```

4. **noImplicitAny オプション**の挙動を確認してみる  
   - `tsconfig.json` で `"noImplicitAny": true` にしてから、型注釈なしの変数宣言や空のオブジェクトリテラルをどのように扱うか試してみてください。

---

## 2-2. 配列と基本演算

### 概要

数値や文字列の配列を操作し、型推論と配列操作の基本を学ぶ課題です。  
> **Note:** TypeScriptでは配列も型を持ち、`number[]`（数値の配列）や`string[]`（文字列の配列）のように表現します。配列のメソッドも型情報を参照するため、型安全に操作できます。

### 目的・ゴール

- 配列型（`number[]`や`string[]`）を正しく扱えるようになる  
- 配列操作のメソッド（`map`、`filter`、`reduce`など）を型安全に使用できるようになる  
- 型推論が配列要素にも適用される仕組みを把握する  
- 空配列宣言時の**暗黙的な `any[]`** 推論に注意できるようになる  

### 手順

1. **`average.ts` ファイルを開いてください。**  
   このファイルには、配列操作に関する課題が用意されています。

2. **ファイル内の指示に従って、以下の実装を行ってください：**
   - 数値配列を受け取り、平均値を返す関数の実装  
   - 空配列の場合のエラーハンドリング  
   - （任意）文字列配列にも対応した関数の実装  

3. **配列の型推論を試してみましょう（追加ステップ）**
   1. 次のように型注釈なしの空配列を作成して要素を追加してみてください。

      ```ts
      let numbers = [];
      numbers.push(10);
      numbers.push(20);
      ```

   2. `numbers` は TypeScript でどのように推論されていますか？  
   3. 次に、最初から要素を持って宣言してみてください。  

      ```ts
      let numbers2 = [10, 20];
      ```

      こちらは `number[]` と推論されるはずです。  
   4. `numbers2.push("30")` を試したとき、エラーが出るか確認してください。  

4. **コードをトランスパイルして実行し、出力結果を確認してください。**

   ```bash
   # プロジェクトのトランスパイル
   npm run build

   # 実行
   node dist/2-values-types-variables/average.js
   ```

5. **様々な配列（空配列、負の数を含む配列など）で関数をテストし、結果を確認してください。**  

6. **実装が完了したら、テストを実行して正しく実装できているか確認しましょう。**

   ```bash
   npm run test -- src/2-values-types-variables/average.test.ts
   ```

### チェックポイント

- 配列型の定義と使用方法を理解しているか  
- `reduce`や`map`などの配列メソッドを適切に使用できるか  
- エラーハンドリング（空配列など特殊ケース）を適切に実装できるか  
- **空配列を型注釈なしで宣言したときの型推論**に注意できるか  
- TypeScriptの型推論が配列操作でどのように機能するか理解できるか  

### 発展課題（任意）

1. **数値配列の中央値（メディアン）を計算する関数**を実装してみましょう。  
   - 要素数が奇数の場合は中央の値、偶数の場合は中央2つの値の平均を返す。
2. **文字列配列に対応**した関数で、文字列の平均長を計算してみましょう。  
3. **複数の型（数値と文字列）が混在する配列**を扱う方法を考えてみましょう。  
   - ユニオン型 `Array<number | string>` を使う  
   - 型ガードで数値か文字列かを判定する  
4. **関数型プログラミング**の考え方で配列操作を実装してみましょう（純粋関数、副作用の排除など）。  

---

### Deep Dive（任意）

- **インデックスシグネチャ**： `{ [key: string]: number }` のように、オブジェクトのキーを動的に扱う  
- **型ガード**： `typeof`, `instanceof`, `in` 演算子を使って実行時に型を判定する  
- **noImplicitAny オプション**： `tsconfig.json` の設定を変更して、暗黙的な `any` を禁止するとどうエラーが変わるか確認する  
