# 7. ジェネリクス (Generics)

このセクションでは、TypeScriptのジェネリクスについて学びます。ジェネリクスは型安全なプログラミングを可能にする強力な機能です。「関数中心」のコード例を通じて、あらゆる型を安全に扱う仕組みを体験していきます。

## 7-1. ジェネリック関数の基本

### 概要

配列とインデックスを受け取り、その要素を安全に返す汎用関数 `getElement` を作る課題です。クラスを使わずに**純粋関数**として実装し、ジェネリクスの恩恵（型推論・あらゆる型対応）を体験します。

> **Note:** ジェネリクスは、さまざまな型で動作する関数やクラスを作成するためのTypeScriptの機能です。型パラメータ`<T>`を使って、使用時に型を指定または推論できます。

### 目的・ゴール

- ジェネリック関数の基本的な書き方を理解する
- 型パラメータ`<T>`の使い方を習得する
- 関数の型シグネチャを適切に定義できるようになる
- ジェネリクスを使った型安全なコードの書き方を身につける

### 手順

1. `src/7-generics/getElement.ts` ファイルを開いてください。

2. TODOコメントに従って以下の実装を行ってください：
   - 配列とインデックスを受け取り、そのインデックスの要素を返す関数 `getElement` を実装
   - 配列の範囲外の場合は `undefined` を返すようにする
   - 関数内部は副作用を持たない純粋関数として実装
   - **型パラメータ `<T>` を使って、ジェネリック関数として定義する**

   関数定義の形は以下のようになります：

   ```ts
   function getElement<T>(引数): 戻り値の型 {
     // 実装
   }
   ```

3. ファイル内のテストコードを使って動作確認を行います。

4. **トランスパイルして実行**
   ```bash
   npm run build
   node dist/7-generics/getElement.js
   ```

5. **テストを実行して確認**
   ```bash
   npm run test -- src/7-generics/getElement.test.ts
   ```

### チェックポイント

- ジェネリックな型パラメータ`<T>`を正しく使えているか
- 配列内の要素を型安全に取得できるか
- インデックスが範囲外の場合のエラーハンドリングができているか
- 関数の型シグネチャが正しいか（引数と戻り値の型）

### ジェネリクスの利点

- `any` や ユニオン型ではなく、`<T>` で配列要素の型を表現できる
- **引数の型をそのまま戻り値にも反映**できるため、呼び出し側で型推論が効く
- 純粋関数として書くことで、外部状態の変更や副作用を最小化（FP でよく推奨される作り）

## 7-2. 複数型パラメータを使う

### 概要

2つのオブジェクトをマージする関数 `merge` を実装する課題です。**複数の型パラメータ `<A, B>`** を使うと、戻り値が「A と B 両方の型」を統合したものになります。

### 目的・ゴール

- 複数の型パラメータを持つジェネリック関数を実装できるようになる
- 交差型（Intersection Types）`A & B`の使い方と意味を理解する
- ジェネリクスを使った型安全なオブジェクト合成を行えるようになる

### 手順

1. `src/7-generics/merge.ts` ファイルを開いてください。

2. 以下の仕様を満たす関数を実装してください：
   - 2つのオブジェクト `objA` と `objB` を受け取り、それらをマージした新しいオブジェクトを返す
   - **型パラメータとして `<A, B>` を自分で定義し、さまざまな型のオブジェクトに対応できるようにする**
   - **戻り値の型として交差型 `A & B` を使用し、両方のプロパティを持つ型にする**
   - オブジェクトのマージには、スプレッド構文 `{ ...objA, ...objB }` を使用する

   関数の型シグネチャは自分で考えて書いてください：

   ```ts
   function merge<型パラメータ>(引数): 戻り値の型 {
     // 実装
   }
   ```

3. ファイル内のテストコードを使って動作確認を行います。

4. **トランスパイルして実行**
   ```bash
   npm run build
   node dist/7-generics/merge.js
   ```

5. **テストを実行して確認**
   ```bash
   npm run test -- src/7-generics/merge.test.ts
   ```

### チェックポイント

- 複数の型パラメータ`<A, B>`を正しく定義できているか
- 交差型`A & B`を戻り値の型として適切に使用できているか
- オブジェクトのマージが正しく行われているか
- 関数が純粋関数として、元のオブジェクトを変更せず新しいオブジェクトを返しているか

### ヒント

- `<A, B>` のように型パラメータが2つ以上あるときは、カンマ区切りで記述します
- `A & B` は「交差型」と呼ばれ、両方のプロパティを兼ね備える型を表します
- 現実のコードでも「オブジェクトを合成して新しいオブジェクトを返す」関数を純粋関数で書くケースは多いです

## 7-3. 制約 (`extends`) の活用

### 概要

オブジェクト配列から特定のプロパティを取り出す関数 `pluck` を作る課題です。**型パラメータに制約をつける** ことで、存在するプロパティ名のみを指定できるようにします。

### 目的・ゴール

- 型パラメータに制約（`extends`）を追加する方法を理解する
- `keyof` 演算子の使い方を習得する
- 型安全なプロパティアクセスを実装できるようになる
- インデックス型アクセス（`T[K]`）の使い方を学ぶ

### 手順

1. `src/7-generics/pluck.ts` ファイルを開いてください。

2. 以下の仕様を満たす関数を実装してください：
   - オブジェクトの配列 `array` とプロパティ名 `key` を受け取る
   - 配列内の各オブジェクトから指定されたプロパティの値を抽出し、新しい配列として返す
   - **型パラメータとして `<T, K>` を定義し、K は T のプロパティ名のみを受け付けるよう制約する**
   - **戻り値の型は `Array<T[K]>` として、抽出したプロパティの型を正しく反映させる**

   関数の型シグネチャは自分で考えて書いてください：

   ```ts
   function pluck<型パラメータと制約>(引数): 戻り値の型 {
     // 実装
   }
   ```

   実装のヒント:
   - `array.map()` メソッドを使って各要素から特定のプロパティを抽出

3. ファイル内のテストコードを使って動作確認を行います。

4. **トランスパイルして実行**
   ```bash
   npm run build
   node dist/7-generics/pluck.js
   ```

5. **テストを実行して確認**
   ```bash
   npm run test -- src/7-generics/pluck.test.ts
   ```

### チェックポイント

- 型パラメータに制約（`K extends keyof T`）を正しく追加できているか
- `keyof` 演算子を使って型のプロパティキーを抽出できているか
- 戻り値の型を`Array<T[K]>`として正しく定義できているか
- 存在しないプロパティ名を指定するとコンパイルエラーになることを確認できているか

### ヒント

- `K extends keyof T` は「K は T のキーのいずれか」という制約を表します
- この制約により、存在しないプロパティ名を指定するとコンパイルエラーになります
- `keyof` 演算子はオブジェクト型からそのプロパティ名の型（union型）を生成します
- `T[K]` 記法でプロパティの型を取得できます

### 発展課題（任意）

以下はジェネリクスをより深堀りしたい方への追加演習です：

1. **制約付きジェネリック関数**  
   - `function getName<T extends { name: string }>(obj: T) { ... }` のように、必ず `name` プロパティを持つオブジェクトだけ受け取れる関数を書いてみましょう。  
   - 制約を満たさない引数を与えるとどうなるか、コンパイルエラーを確認してみてください。

2. **`Partial<T>` / `Pick<T, K>` / `Omit<T, K>` などユーティリティ型との組み合わせ**  
   - 組み込みユーティリティ型とジェネリクスを掛け合わせると、実務で「部分更新関数」「特定プロパティだけ抽出する関数」などを簡単に作れます。  
   - 例: `function updateObject<T>(obj: T, patch: Partial<T>): T { ... }`

3. **ビルトイン配列メソッドの再実装**  
   - `mapArray<T, U>`, `filterArray<T>` などを自作してみて、`Array<T>` がどのようにジェネリクスを使っているかを学んでみましょう。

---

## 学習のポイント

1. **ジェネリクスの核心**  
   - **「型パラメータ `<T>` が、渡したデータ型をそのまま表現する」** → 汎用コードを安全に書ける  
   - 関数ベースでもクラスベースでも、考え方は同じ：コンストラクタ・引数などから推論された型を内部で活用する

2. **型推論の強みと明示指定**  
   - 多くの場合は呼び出し時に `getElement(numArray, 1)` と書けば勝手に推論される  
   - ただし戻り値だけで型が決定しない場合や、推論エラーが出る場合は `<T>` を明示することも必要

3. **制約 (`extends`) で安全性を高める**  
   - 「渡すデータが特定のプロパティ／メソッドを持つはず」という前提を、型レベルで保証できる  
   - 実装中や呼び出し側で間違っているとコンパイル時に気づけるため、バグを未然に防ぐ

4. **純粋関数との相性の良さ**  
   - 配列やオブジェクトを「不変（immutable）」に扱う関数であれば、ジェネリクスによる型安全性がさらに明確に活きる
